

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Piggytuotuo</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2023-05-21T19:09:55+08:00</updated>
  <author>
    <name>Piggytuotuo</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Piggytuotuo </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Diff Nums</title>
    <link href="http://localhost:4000/posts/leetcode-diffnum/" rel="alternate" type="text/html" title="Diff Nums" />
    <published>2023-05-21T14:46:00+08:00</published>
  
    <updated>2023-05-21T14:46:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-diffnum/</id>
    <content src="http://localhost:4000/posts/leetcode-diffnum/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      前缀和

可以快速求解闭区间[i,j]的和。

class PrefixSum{
    private int[] prefix;

public PrefixSum(int[] nums){
    prefix = new int[nums.length + 1];
    for(int i = 1; i &amp;lt; prefix.length; i++){
        prefix[i] = prefix[i - 1] + nums[i - 1];
    }
}

public int query(int i, int j){
    return prefix[j + 1] - prefix[i];
} }


差分数组

可以快速实现对闭区间[i,j]中的所有元素进行增减。

public class Difference {
    private int[] d...
    </summary>
  

  </entry>

  
  <entry>
    <title>Sliding Windows</title>
    <link href="http://localhost:4000/posts/leetcode-sldingwindows/" rel="alternate" type="text/html" title="Sliding Windows" />
    <published>2023-05-16T14:36:00+08:00</published>
  
    <updated>2023-05-16T14:36:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-sldingwindows/</id>
    <content src="http://localhost:4000/posts/leetcode-sldingwindows/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      框架: O(N)

int left = 0, right = 0;

while(right &amp;lt; s.size()){
    //将有边界字符加入窗口中
    windows.add(s[right]);
    right ++;
    ...
    //根据**一些条件**判断是否需要收缩做窗口
    while(left &amp;lt; right &amp;amp;&amp;amp; window needs shrink){
        windows.remove(s[left]);
        left++;
    }
}


一些条件根据不同的题目确定。

最小覆盖子串
leetcode 76

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：
对于 t...
    </summary>
  

  </entry>

  
  <entry>
    <title>Git</title>
    <link href="http://localhost:4000/posts/git/" rel="alternate" type="text/html" title="Git" />
    <published>2023-05-13T14:44:00+08:00</published>
  
    <updated>2023-05-13T14:44:00+08:00</updated>
  
    <id>http://localhost:4000/posts/git/</id>
    <content src="http://localhost:4000/posts/git/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Version Control" />
    
  

  
    <summary>
      





      关于Git
Git为版本管理工具，可以使用Git将代码提交到github、gitee等代码社区中，实现版本管理。

Git仓库中的默认分支为main（之前为master）.
在Github或其他平台上创建仓库后，会创建一个默认的main分支。

一般情况下，可以在远程创建一个空仓库，然后将本地的代码提交到远程分支中。

在规范的开发流程中，通常使用dev + main：

  
    main分支用于保存发布的代码版本。代码是稳定可靠的，任何使用都可以基于main分支部署。
  
  
    dev分支是开发分支，当在dev分支上开发一个新功能后，需要发布时，创建一个release分支。经过测试合并后再合并回main分支。
  


Windows上使用Git

1.下载安装git Git - Downloading Package

2.在git bash中设置git的用户名和...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java 多线程</title>
    <link href="http://localhost:4000/posts/java-threads/" rel="alternate" type="text/html" title="Java 多线程" />
    <published>2023-05-11T20:34:00+08:00</published>
  
    <updated>2023-05-11T20:34:00+08:00</updated>
  
    <id>http://localhost:4000/posts/java-threads/</id>
    <content src="http://localhost:4000/posts/java-threads/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Java Concurrency" />
    
  

  
    <summary>
      





      实现并行完成多个任务。提高cpu的利用率。

三种实现方式

public class LearnThreads {
    public static void main(String[] args) {
        //1. 继承Thread类，实例化一个Thread对象
        Thread mt = new MyThread();
        mt.start();

        // 2. 实例化一个Runnable对象，作为参数传给Thread类
        MyRunnable instance = new MyRunnable();
        Thread thread = new Thread(instance);
        thread.start();

        //3. 实例化一个Callable对象，作为参数传给F...
    </summary>
  

  </entry>

  
  <entry>
    <title>Tree</title>
    <link href="http://localhost:4000/posts/leetcode-tree/" rel="alternate" type="text/html" title="Tree" />
    <published>2023-05-09T10:00:00+08:00</published>
  
    <updated>2023-05-09T10:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-tree/</id>
    <content src="http://localhost:4000/posts/leetcode-tree/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      LeetCode中关于二叉树的一些问题

判断树是否对称

leetcode 剑指Offer 28

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
    1
   / \
  2   2
   \   \
   3    3

示例 1：
输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：
输入：root = [1,2,2,null,3,null,3]
输出：false


满足镜像对称的条件：
对于镜像对称的一对节点L和R:

L.val == R.val

L.right.val == R...
    </summary>
  

  </entry>

</feed>


