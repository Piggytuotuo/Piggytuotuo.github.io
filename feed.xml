

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Piggytuotuo</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2023-06-08T13:09:49+08:00</updated>
  <author>
    <name>Piggytuotuo</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Piggytuotuo </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>DP-Creational Pattern-Factory</title>
    <link href="http://localhost:4000/posts/dp-creational-factory/" rel="alternate" type="text/html" title="DP-Creational Pattern-Factory" />
    <published>2023-06-08T12:00:00+08:00</published>
  
    <updated>2023-06-08T12:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/dp-creational-factory/</id>
    <content src="http://localhost:4000/posts/dp-creational-factory/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      工厂模式：解耦

创建对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

简单工厂



工厂方法



抽象工厂



原型Prototype



建造者Builder



    </summary>
  

  </entry>

  
  <entry>
    <title>DP-Structural Pattern-Proxy-JDK</title>
    <link href="http://localhost:4000/posts/dp-structural-proxy-jdk/" rel="alternate" type="text/html" title="DP-Structural Pattern-Proxy-JDK" />
    <published>2023-06-07T17:16:00+08:00</published>
  
    <updated>2023-06-08T12:11:28+08:00</updated>
  
    <id>http://localhost:4000/posts/dp-structural-proxy-jdk/</id>
    <content src="http://localhost:4000/posts/dp-structural-proxy-jdk/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      Proxy

代理作为访问对象和目标对象之间的中介。

作用：

  降低系统耦合度
  代理对象调用目标对象时可以对目标对象进行增强。


分为：


  静态代理：编译时生成代理类
  动态代理：运行时动态生成代理类，基于反射
    
      JDK代理：必须定义接口
      CGLib代理：可以代理没实现接口的类
    
  


动态代理-JDK代理

1.接口类：卖票

public interface SellTickets {
    void sell();
}


2.具体实现类：火车站卖票

public class TrainStation implements SellTickets{
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
...
    </summary>
  

  </entry>

  
  <entry>
    <title>DP-Structural Pattern-Proxy-GCLib</title>
    <link href="http://localhost:4000/posts/dp-structural-proxy-gclib/" rel="alternate" type="text/html" title="DP-Structural Pattern-Proxy-GCLib" />
    <published>2023-06-07T17:16:00+08:00</published>
  
    <updated>2023-06-08T12:11:28+08:00</updated>
  
    <id>http://localhost:4000/posts/dp-structural-proxy-gclib/</id>
    <content src="http://localhost:4000/posts/dp-structural-proxy-gclib/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      动态代理-GCLIB代理

1.具体实现类

public class TrainStation {
    public void sell(){
        System.out.println("火车站卖票");
    }
}


2.代理工厂类

//代理对象是目标对象所属类别的子类
//使用enhancer的create方法获取代理对象
public class ProxyFactory implements MethodInterceptor {

    private TrainStation station = new TrainStation();
    public TrainStation getProxyObject(){
        //创建Enhancer对象，类似JDK代理中的Proxy类
        Enhancer enhancer...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java Web Bug记录</title>
    <link href="http://localhost:4000/posts/javaweb-bugs/" rel="alternate" type="text/html" title="Java Web Bug记录" />
    <published>2023-06-03T14:35:00+08:00</published>
  
    <updated>2023-06-08T12:11:28+08:00</updated>
  
    <id>http://localhost:4000/posts/javaweb-bugs/</id>
    <content src="http://localhost:4000/posts/javaweb-bugs/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Develop" />
    
  

  
    <summary>
      





      Bug1

Only a type can be imported. com.xxx.xxx.XXX resolves to a package.


背景：jsp中导入java包，并部署在tomcat运行时报错。

原因：在jsp中没有找到相关的java类。

解决：生成web项目的artifact时，还没有写java类，所以tomcat找不到。写了java类之后应该重新生成artifact。

Bug2

Dependency ... not found.


背景：配置依赖时，在mvn仓库中可以查到，但是显示找不到依赖

原因：mvn配置有问题

解决：File - Settings - Build,Execution,Deployment - Build Tools - Maven 设置mvn的User setting files和Local repository。若还有问题...
    </summary>
  

  </entry>

  
  <entry>
    <title>DP-Creational Pattern-Singleton</title>
    <link href="http://localhost:4000/posts/dp-creational-singleton/" rel="alternate" type="text/html" title="DP-Creational Pattern-Singleton" />
    <published>2023-05-21T14:46:00+08:00</published>
  
    <updated>2023-05-21T14:46:00+08:00</updated>
  
    <id>http://localhost:4000/posts/dp-creational-singleton/</id>
    <content src="http://localhost:4000/posts/dp-creational-singleton/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      单例Singleton

私有构造函数 + 私有静态变量 + 公有静态函数

只能通过共有静态函数返回唯一的私有静态变量。

饿汉式-静态变量

直接实例化。
优点：线程安全。缺点：不节约资源。

private static Singleton uniqueInstance = new Singleton();


饿汉式-静态代码块

懒汉式-线程不安全

在获取实例时，若没有实例化，再进行实例化。
优点：节约资源；缺点：线程不安全。

public class Singleton {
    private static Singleton uniqueInstance;
    private Singleton(){
    }
    public static Singleton getInstance(){
        //懒汉式：需要的时候在进行实例化。线程不安...
    </summary>
  

  </entry>

</feed>


