

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Piggytuotuo</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2023-05-16T14:18:34+08:00</updated>
  <author>
    <name>Piggytuotuo</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Piggytuotuo </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Git</title>
    <link href="http://localhost:4000/posts/git/" rel="alternate" type="text/html" title="Git" />
    <published>2023-05-13T14:44:00+08:00</published>
  
    <updated>2023-05-13T14:44:00+08:00</updated>
  
    <id>http://localhost:4000/posts/git/</id>
    <content src="http://localhost:4000/posts/git/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Version Control" />
    
  

  
    <summary>
      





      关于Git
Git为版本管理工具，可以使用Git将代码提交到github、gitee等代码社区中，实现版本管理。

Git仓库中的默认分支为main（之前为master）.
在Github或其他平台上创建仓库后，会创建一个默认的main分支。

一般情况下，可以在远程创建一个空仓库，然后将本地的代码提交到远程分支中。

在规范的开发流程中，通常使用dev + main：

  
    main分支用于保存发布的代码版本。代码是稳定可靠的，任何使用都可以基于main分支部署。
  
  
    dev分支是开发分支，当在dev分支上开发一个新功能后，需要发布时，创建一个release分支。经过测试合并后再合并回main分支。
  


Windows上使用Git

1.下载安装git Git - Downloading Package

2.在git bash中设置git的用户名和...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java 多线程</title>
    <link href="http://localhost:4000/posts/java-threads/" rel="alternate" type="text/html" title="Java 多线程" />
    <published>2023-05-11T20:34:00+08:00</published>
  
    <updated>2023-05-11T20:34:00+08:00</updated>
  
    <id>http://localhost:4000/posts/java-threads/</id>
    <content src="http://localhost:4000/posts/java-threads/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Java Concurrency" />
    
  

  
    <summary>
      





      实现并行完成多个任务。提高cpu的利用率。

三种实现方式

public class LearnThreads {
    public static void main(String[] args) {
        //1. 继承Thread类，实例化一个Thread对象
        Thread mt = new MyThread();
        mt.start();

        // 2. 实例化一个Runnable对象，作为参数传给Thread类
        MyRunnable instance = new MyRunnable();
        Thread thread = new Thread(instance);
        thread.start();

        //3. 实例化一个Callable对象，作为参数传给F...
    </summary>
  

  </entry>

  
  <entry>
    <title>Tree</title>
    <link href="http://localhost:4000/posts/leetcode-tree/" rel="alternate" type="text/html" title="Tree" />
    <published>2023-05-09T10:00:00+08:00</published>
  
    <updated>2023-05-09T10:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-tree/</id>
    <content src="http://localhost:4000/posts/leetcode-tree/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      LeetCode中关于二叉树的一些问题

判断树是否对称

leetcode 剑指Offer 28

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
    1
   / \
  2   2
   \   \
   3    3

示例 1：
输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：
输入：root = [1,2,2,null,3,null,3]
输出：false


满足镜像对称的条件：
对于镜像对称的一对节点L和R:

L.val == R.val

L.right.val == R...
    </summary>
  

  </entry>

  
  <entry>
    <title>Recursion</title>
    <link href="http://localhost:4000/posts/leetcode-recursion/" rel="alternate" type="text/html" title="Recursion" />
    <published>2023-04-27T10:12:00+08:00</published>
  
    <updated>2023-04-27T10:12:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-recursion/</id>
    <content src="http://localhost:4000/posts/leetcode-recursion/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      原理

思想：自己调用自己。将原问题分解为规模更小的子问题，并不断调用自己来解决这些子问题，当问题规模足够小，就直接解决而不再需要调用，此时就是找到了base case。

函数执行过程：一系列栈帧的的压入和弹出。每次递归调用会压入一个新的栈帧，保存当前的状态，包括函数参数，局部变量及函数返回地址等信息。当递归调用结束时，栈帧会被弹出，根据返回地址返回到上一个调用点继续执行。最终所有栈帧都会被弹出，程序执行结束。

栈帧保在JVM的栈区中。假如P调用Q，则Q的栈帧中的返回地址为调用Q的指令的下一条指令的地址。

框架

递归调用之前的代码正序执行： 前序位置

递归调用之后的代码倒序执行： 后序位置

递归遍历数组

//递归遍历数组
public static void traverseArray(int[] arr, int i) {
	if(i == arr.length) r...
    </summary>
  

  </entry>

  
  <entry>
    <title>排序-TopK</title>
    <link href="http://localhost:4000/posts/leetcode-topk/" rel="alternate" type="text/html" title="排序-TopK" />
    <published>2023-04-26T14:46:00+08:00</published>
  
    <updated>2023-04-26T14:46:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-topk/</id>
    <content src="http://localhost:4000/posts/leetcode-topk/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      使用QuickSort和HeapSort解决TopK问题。

QuickSort O(NlogN)
定义快排的partition操作：使用a[l]作为切分元素，从左向右扫描数组，找到第一个&amp;gt;= a[l]的元素，再从右向左扫描数组，找到第一个&amp;lt; a[l]的元素，交换这两个元素，当两个指针相遇，将切分元素a[l]和a[j]交换位置。

public static int partition(int[] nums, int l, int h) {
	//扫描数组，找到第一个&amp;gt;=al的 和 第一个&amp;lt; al的
	int i = l, j = h + 1;
	int flag = nums[l];
	while(true) {
		while(nums[++i] &amp;lt; flag &amp;amp;&amp;amp; i &amp;lt; h);
		while(nums[--j] &amp;gt;=...
    </summary>
  

  </entry>

</feed>


