

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Piggytuotuo</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2023-05-09T11:14:18+08:00</updated>
  <author>
    <name>Piggytuotuo</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Piggytuotuo </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Tree</title>
    <link href="http://localhost:4000/posts/leetcode-tree/" rel="alternate" type="text/html" title="Tree" />
    <published>2023-05-09T10:00:00+08:00</published>
  
    <updated>2023-05-09T10:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-tree/</id>
    <content src="http://localhost:4000/posts/leetcode-tree/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      LeetCode中关于二叉树的一些问题

判断树是否对称

leetcode 剑指Offer 28

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
    1
   / \
  2   2
   \   \
   3    3

示例 1：
输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：
输入：root = [1,2,2,null,3,null,3]
输出：false


满足镜像对称的条件：
对于镜像对称的一对节点L和R:

L.val == R.val

L.right.val == R...
    </summary>
  

  </entry>

  
  <entry>
    <title>Recursion</title>
    <link href="http://localhost:4000/posts/leetcode-recursion/" rel="alternate" type="text/html" title="Recursion" />
    <published>2023-04-27T10:12:00+08:00</published>
  
    <updated>2023-04-27T10:12:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-recursion/</id>
    <content src="http://localhost:4000/posts/leetcode-recursion/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      原理

思想：自己调用自己。将原问题分解为规模更小的子问题，并不断调用自己来解决这些子问题，当问题规模足够小，就直接解决而不再需要调用，此时就是找到了base case。

函数执行过程：一系列栈帧的的压入和弹出。每次递归调用会压入一个新的栈帧，保存当前的状态，包括函数参数，局部变量及函数返回地址等信息。当递归调用结束时，栈帧会被弹出，根据返回地址返回到上一个调用点继续执行。最终所有栈帧都会被弹出，程序执行结束。

栈帧保在JVM的栈区中。假如P调用Q，则Q的栈帧中的返回地址为调用Q的指令的下一条指令的地址。

框架

递归调用之前的代码正序执行： 前序位置

递归调用之后的代码倒序执行： 后序位置

递归遍历数组

//递归遍历数组
public static void traverseArray(int[] arr, int i) {
	if(i == arr.length) r...
    </summary>
  

  </entry>

  
  <entry>
    <title>排序-TopK</title>
    <link href="http://localhost:4000/posts/leetcode-topk/" rel="alternate" type="text/html" title="排序-TopK" />
    <published>2023-04-26T14:46:00+08:00</published>
  
    <updated>2023-04-26T14:46:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-topk/</id>
    <content src="http://localhost:4000/posts/leetcode-topk/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      使用QuickSort和HeapSort解决TopK问题。

QuickSort O(NlogN)
定义快排的partition操作：使用a[l]作为切分元素，从左向右扫描数组，找到第一个&amp;gt;= a[l]的元素，再从右向左扫描数组，找到第一个&amp;lt; a[l]的元素，交换这两个元素，当两个指针相遇，将切分元素a[l]和a[j]交换位置。

public static int partition(int[] nums, int l, int h) {
	//扫描数组，找到第一个&amp;gt;=al的 和 第一个&amp;lt; al的
	int i = l, j = h + 1;
	int flag = nums[l];
	while(true) {
		while(nums[++i] &amp;lt; flag &amp;amp;&amp;amp; i &amp;lt; h);
		while(nums[--j] &amp;gt;=...
    </summary>
  

  </entry>

  
  <entry>
    <title>二分</title>
    <link href="http://localhost:4000/posts/leetcode-bs/" rel="alternate" type="text/html" title="二分" />
    <published>2023-04-21T10:05:00+08:00</published>
  
    <updated>2023-04-21T10:05:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-bs/</id>
    <content src="http://localhost:4000/posts/leetcode-bs/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      搜索一个数

搜索区间为 [left, right)

left = 0, right = nums.length;

while(left &amp;lt; right){
    int mid = (right - left) / 2 + left;
    if(nums[mid] == target){
        return mid;
    }else if(nums[mid] &amp;lt; target){
        left = mid + 1;
    }else{
        right = mid;
    }
}


搜索区间为 [left, right] √

left = 0, right = nums.length - 1;

while(left &amp;lt;= right){
    int mid = (right - left) / 2 + l...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java Reflection</title>
    <link href="http://localhost:4000/posts/java-reflection/" rel="alternate" type="text/html" title="Java Reflection" />
    <published>2023-04-20T00:40:00+08:00</published>
  
    <updated>2023-04-20T00:40:00+08:00</updated>
  
    <id>http://localhost:4000/posts/java-reflection/</id>
    <content src="http://localhost:4000/posts/java-reflection/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Java Foundation" />
    
  

  
    <summary>
      





      Java Reflection

一、定义

反射是Java被视为动态语言的关键，可以在运行时动态的获取对象所属的类，动态调用方法，包括私有的属性、方法、构造器。

在设计框架时会用到大量反射。

框架 = 注解 + 反射 + 设计模式。

通过反射，可以创造单例模式中类的多个对象。

二、Class对象

每个类都有一个Class对象/实例，包含了与类有关的信息。当编译一个新类时，会产生一个同名的.class文件，该文件保存这个Class对象。

类加载相当于Class对象的加载，类在第一次使用时才动态的加载到JVM中。

比如：加载到内存中的Person、String类，都作为Class的对象/实例。

Class clazz1 = Person.class; //运行时类
Class clazz2 = String.class;


Class对象的三种获取方式：

//1. ...
    </summary>
  

  </entry>

</feed>


