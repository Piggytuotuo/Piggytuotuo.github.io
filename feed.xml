

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Piggytuotuo</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2023-04-26T22:23:11+08:00</updated>
  <author>
    <name>Piggytuotuo</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Piggytuotuo </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>TopK</title>
    <link href="http://localhost:4000/posts/leetcode-topk/" rel="alternate" type="text/html" title="TopK" />
    <published>2023-04-26T14:46:00+08:00</published>
  
    <updated>2023-04-26T14:46:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-topk/</id>
    <content src="http://localhost:4000/posts/leetcode-topk/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      使用QuickSort和HeapSort解决TopK问题。

QuickSort O(NlogN)
定义快排的partition操作：使用a[l]作为切分元素，从左向右扫描数组，找到第一个&amp;gt;= a[l]的元素，再从右向左扫描数组，找到第一个&amp;lt; a[l]的元素，交换这两个元素，当两个指针相遇，将切分元素a[l]和a[j]交换位置。

public static int partition(int[] nums, int l, int h) {
	//扫描数组，找到第一个&amp;gt;=al的 和 第一个&amp;lt; al的
	int i = l, j = h + 1;
	int flag = nums[l];
	while(true) {
		while(nums[++i] &amp;lt; flag &amp;amp;&amp;amp; i &amp;lt; h);
		while(nums[--j] &amp;gt;=...
    </summary>
  

  </entry>

  
  <entry>
    <title>二分</title>
    <link href="http://localhost:4000/posts/leetcode-bs/" rel="alternate" type="text/html" title="二分" />
    <published>2023-04-21T10:05:00+08:00</published>
  
    <updated>2023-04-21T10:05:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-bs/</id>
    <content src="http://localhost:4000/posts/leetcode-bs/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      搜索一个数

搜索区间为 [left, right)

left = 0, right = nums.length;

while(left &amp;lt; right){
    int mid = (right - left) / 2 + left;
    if(nums[mid] == target){
        return mid;
    }else if(nums[mid] &amp;lt; target){
        left = mid + 1;
    }else{
        right = mid;
    }
}


搜索区间为 [left, right] √

left = 0, right = nums.length - 1;

while(left &amp;lt;= right){
    int mid = (right - left) / 2 + l...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java反射</title>
    <link href="http://localhost:4000/posts/java-reflection/" rel="alternate" type="text/html" title="Java反射" />
    <published>2023-04-20T00:40:00+08:00</published>
  
    <updated>2023-04-20T00:40:00+08:00</updated>
  
    <id>http://localhost:4000/posts/java-reflection/</id>
    <content src="http://localhost:4000/posts/java-reflection/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Java基础" />
    
  

  
    <summary>
      





      Java Reflection

一、定义

反射是Java被视为动态语言的关键，可以在运行时动态的获取对象所属的类，动态调用方法，包括私有的属性、方法、构造器。

在设计框架时会用到大量反射。

框架 = 注解 + 反射 + 设计模式。

通过反射，可以创造单例模式中类的多个对象。

二、Class对象

每个类都有一个Class对象/实例，包含了与类有关的信息。当编译一个新类时，会产生一个同名的.class文件，该文件保存这个Class对象。

类加载相当于Class对象的加载，类在第一次使用时才动态的加载到JVM中。

比如：加载到内存中的Person、String类，都作为Class的对象/实例。

Class clazz1 = Person.class; //运行时类
Class clazz2 = String.class;


Class对象的三种获取方式：

//1. ...
    </summary>
  

  </entry>

  
  <entry>
    <title>DP-树形DP</title>
    <link href="http://localhost:4000/posts/leetcode-dp-tree/" rel="alternate" type="text/html" title="DP-树形DP" />
    <published>2023-04-18T18:00:00+08:00</published>
  
    <updated>2023-04-19T13:52:48+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-dp-tree/</id>
    <content src="http://localhost:4000/posts/leetcode-dp-tree/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      树形DP

数据之间存在树状关系，使用邻接表存储数据，实现方法是DFS.

框架：

void dfs(int v){
    dp[v] = ...;
    for(int u: G[v]){//遍历v的所有子节点
        dfs(u); //确保子节点的值已经更新好
        update(u, v);//用子节点的dp值对当前节点的dp值铏更新
    }
}


子树大小

给定一棵有N个结点的树，根结点为结点1。对于i = 1 , 2 , … , N
求以结点i为根的子树大小（即子树上结点的个数，包括根结点）。

输入：
第一行输入N
接下来N-1行，输入两个整数u, v, 代表u的父亲结点编号为v。
输出：
N个数，用空格分隔，第i个数代表以i为根的子树的大小。


使用**邻接表List[]**存储树形结构，从根节点开始dfs，先更新根的子树的大小，然后...
    </summary>
  

  </entry>

  
  <entry>
    <title>DP-背包问题</title>
    <link href="http://localhost:4000/posts/leetcode-dp-bag/" rel="alternate" type="text/html" title="DP-背包问题" />
    <published>2023-04-18T15:00:00+08:00</published>
  
    <updated>2023-04-18T15:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-dp-bag/</id>
    <content src="http://localhost:4000/posts/leetcode-dp-bag/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      背包问题

属于动态规划的一类问题，需要明确状态和选择。

状态：背包的容量 和 可选择的物品；选择：装 和 不装

01背包：

每个物品只能装一次，选择装/不装。

定义状态转移方程dp[i][w]：

对于前i个物品，当前背包的容量是w时，可以获得的最大价值是dp[i][w]。

int[][] dp = new int[N+1][M+1]
//base case
dp[0][...] = 0
dp[...][0] = 0
//使用wt[i-1]表示第i个物品的重量 val[i-1]表示第i个物品的价值
for i in [1...N]:
    for w in [1...M]:
        //考虑                 不装入     装入
        dp[i][w] = Math.max(dp[i-1][w],  dp[i-1][w-wt[i-1]]...
    </summary>
  

  </entry>

</feed>


