

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Piggytuotuo</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2023-04-27T14:06:19+08:00</updated>
  <author>
    <name>Piggytuotuo</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Piggytuotuo </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Recursion</title>
    <link href="http://localhost:4000/posts/leetcode-recursion/" rel="alternate" type="text/html" title="Recursion" />
    <published>2023-04-27T10:12:00+08:00</published>
  
    <updated>2023-04-27T10:12:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-recursion/</id>
    <content src="http://localhost:4000/posts/leetcode-recursion/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      原理

思想：自己调用自己。将原问题分解为规模更小的子问题，并不断调用自己来解决这些子问题，当问题规模足够小，就直接解决而不再需要调用，此时就是找到了base case。

函数执行过程：一系列栈帧的的压入和弹出。每次递归调用会压入一个新的栈帧，保存当前的状态，包括函数参数，局部变量及函数返回地址等信息。当递归调用结束时，栈帧会被弹出，根据返回地址返回到上一个调用点继续执行。最终所有栈帧都会被弹出，程序执行结束。

栈帧保在JVM的栈区中。假如P调用Q，则Q的栈帧中的返回地址为调用Q的指令的下一条指令的地址。

框架

递归调用之前的代码正序执行： 前序位置

递归调用之后的代码倒序执行： 后序位置

递归遍历数组

//递归遍历数组
public static void traverseArray(int[] arr, int i) {
	if(i == arr.length) r...
    </summary>
  

  </entry>

  
  <entry>
    <title>排序-TopK</title>
    <link href="http://localhost:4000/posts/leetcode-topk/" rel="alternate" type="text/html" title="排序-TopK" />
    <published>2023-04-26T14:46:00+08:00</published>
  
    <updated>2023-04-26T14:46:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-topk/</id>
    <content src="http://localhost:4000/posts/leetcode-topk/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      使用QuickSort和HeapSort解决TopK问题。

QuickSort O(NlogN)
定义快排的partition操作：使用a[l]作为切分元素，从左向右扫描数组，找到第一个&amp;gt;= a[l]的元素，再从右向左扫描数组，找到第一个&amp;lt; a[l]的元素，交换这两个元素，当两个指针相遇，将切分元素a[l]和a[j]交换位置。

public static int partition(int[] nums, int l, int h) {
	//扫描数组，找到第一个&amp;gt;=al的 和 第一个&amp;lt; al的
	int i = l, j = h + 1;
	int flag = nums[l];
	while(true) {
		while(nums[++i] &amp;lt; flag &amp;amp;&amp;amp; i &amp;lt; h);
		while(nums[--j] &amp;gt;=...
    </summary>
  

  </entry>

  
  <entry>
    <title>二分</title>
    <link href="http://localhost:4000/posts/leetcode-bs/" rel="alternate" type="text/html" title="二分" />
    <published>2023-04-21T10:05:00+08:00</published>
  
    <updated>2023-04-21T10:05:00+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-bs/</id>
    <content src="http://localhost:4000/posts/leetcode-bs/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      搜索一个数

搜索区间为 [left, right)

left = 0, right = nums.length;

while(left &amp;lt; right){
    int mid = (right - left) / 2 + left;
    if(nums[mid] == target){
        return mid;
    }else if(nums[mid] &amp;lt; target){
        left = mid + 1;
    }else{
        right = mid;
    }
}


搜索区间为 [left, right] √

left = 0, right = nums.length - 1;

while(left &amp;lt;= right){
    int mid = (right - left) / 2 + l...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java Reflection</title>
    <link href="http://localhost:4000/posts/java-reflection/" rel="alternate" type="text/html" title="Java Reflection" />
    <published>2023-04-20T00:40:00+08:00</published>
  
    <updated>2023-04-20T00:40:00+08:00</updated>
  
    <id>http://localhost:4000/posts/java-reflection/</id>
    <content src="http://localhost:4000/posts/java-reflection/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="Java Foundation" />
    
  

  
    <summary>
      





      Java Reflection

一、定义

反射是Java被视为动态语言的关键，可以在运行时动态的获取对象所属的类，动态调用方法，包括私有的属性、方法、构造器。

在设计框架时会用到大量反射。

框架 = 注解 + 反射 + 设计模式。

通过反射，可以创造单例模式中类的多个对象。

二、Class对象

每个类都有一个Class对象/实例，包含了与类有关的信息。当编译一个新类时，会产生一个同名的.class文件，该文件保存这个Class对象。

类加载相当于Class对象的加载，类在第一次使用时才动态的加载到JVM中。

比如：加载到内存中的Person、String类，都作为Class的对象/实例。

Class clazz1 = Person.class; //运行时类
Class clazz2 = String.class;


Class对象的三种获取方式：

//1. ...
    </summary>
  

  </entry>

  
  <entry>
    <title>DP-树形DP</title>
    <link href="http://localhost:4000/posts/leetcode-dp-tree/" rel="alternate" type="text/html" title="DP-树形DP" />
    <published>2023-04-18T18:00:00+08:00</published>
  
    <updated>2023-04-19T13:52:48+08:00</updated>
  
    <id>http://localhost:4000/posts/leetcode-dp-tree/</id>
    <content src="http://localhost:4000/posts/leetcode-dp-tree/" />
    <author>
      <name>piggy</name>
    </author>

  
    
    <category term="LeetCode" />
    
  

  
    <summary>
      





      树形DP

数据之间存在树状关系，使用邻接表存储数据，实现方法是DFS.

框架：

void dfs(int v){
    dp[v] = ...;
    for(int u: G[v]){//遍历v的所有子节点
        dfs(u); //确保子节点的值已经更新好
        update(u, v);//用子节点的dp值对当前节点的dp值铏更新
    }
}


子树大小

给定一棵有N个结点的树，根结点为结点1。对于i = 1 , 2 , … , N
求以结点i为根的子树大小（即子树上结点的个数，包括根结点）。

输入：
第一行输入N
接下来N-1行，输入两个整数u, v, 代表u的父亲结点编号为v。
输出：
N个数，用空格分隔，第i个数代表以i为根的子树的大小。


使用**邻接表List[]**存储树形结构，从根节点开始dfs，先更新根的子树的大小，然后...
    </summary>
  

  </entry>

</feed>


