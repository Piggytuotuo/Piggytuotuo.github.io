[
  
  {
    "title": "Java常用代码",
    "url": "/posts/learn-java/",
    "categories": "Java基础",
    "tags": "java",
    "date": "2023-04-13 14:10:00 +0800",
    





    
    "snippet": "在线文档https://www.matools.com/api/java8从键盘输入Scanner sc =new Scanner(System.in);Integer a=sc.nextInt();int、Integer、Doubleint为基本数据类型，Integer为int对应的包装类。在范型中使用IntegerHashMap&lt;String,Integer&gt; mymap=n...",
    "content": "在线文档https://www.matools.com/api/java8从键盘输入Scanner sc =new Scanner(System.in);Integer a=sc.nextInt();int、Integer、Doubleint为基本数据类型，Integer为int对应的包装类。在范型中使用IntegerHashMap&lt;String,Integer&gt; mymap=new HashMap&lt;String,Integer&gt;(); 判断两个int是否相等或Integer与int是否相等，用== 判断两个Integer是否相等用.equals()System.out.println(m.peekFirst()==q.peek()); //not always trueSystem.out.println(m.peekFirst().equals(q.peek()));//Trueint ans=q.peek();System.out.println(m.peekFirst()==ans);//True//int转doubleDouble v=Double.valueOf(intvalue);//double转IntInteger a=(int)doublevalue; //强制转换默认舍弃小数点后的数 Integer b=(int)Math.round(doublevalule);//Math.round四舍五入                //按格式输出String.format(\"%5d\",Integer.valueof(\"3\"));String.format(\"%.2f\",Double.valueof(\"3\"));//四舍五入并保留小数BigDecimal bd=new BigDecimal(\"133.227878\");bd=bd.setScale(5,RoundingMode.HALF_UP);//RoundingMode.UP Roundingode.DOWN最大值最小值//Float Double Byte Character Short Integer LongImax = Integer.MAX_VALUE;Imin = Integer.MIN_VALUE;Math.max((int)a,(int)b);Math.min((int)a,(int)b);排序Arrays.sort()对数组排序，重载了四类方法● sort(T[] a)：对指定T型数组按数字升序排序。● sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。● sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。● sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。Comparator的compare方法默认从小到大（o1的优先级高于o2）：若参数o1&lt;参数o2,返回负值，o1=o2返回0，o1&gt;o2返回正值。//Arrays.sort只支持对包装类进行自定义排序Integer[] a=new Integer[n];//比较器写法//降序排序需要自定义comparatorComparator cmp = new MyComparator();Arrays.sort(a, cmp);class MyComparator implements Comparator&lt;Integer&gt; {    //如果o1小于o2，我们就返回正值，如果o1大于o2我们就返回负值，    //这样颠倒一下，就可以实现反向排序了    @Override    public int compare(Integer o1, Integer o2) {        return o2-o1;    }}//lamda写法Arrays.sort(a, (n1,n2)-&gt;{    return n2 - n1;}); Collections.sort()对List&lt;T&gt;排序 ● sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c):根据指定比较器产生的顺序对指定List进行排序。字符串String转int/longint a = Integer.parseInt(string);long la = Long.parseLong(string); # Int转StringString s = String.valueOf(a);String s = a + \"\";//int转不同进制的Stringint i = 2023;String s = Integer.toBinaryString(i);String s = Integer.toOctalString(i);String s = Integer.toString(i);String s = Integer.toHexString(i); ## StringString s = \"asdefgasdefg\";for(int i = 0; i &lt; s.length(); i++){    char c = s.charAt(i);}s.indexOf('s') //retrun 1s.indexof('s',2) //return 7s.lastIndexOf('s') //return 7s.lastIndexOf('s',6)//return 1string[] ss = s.split(String a);//以字符串a分割字符串String s = s.substring((int)start,(int)end)//[start,end)//String与char数组的转换char[] cs = s.toCharArray();String s = new String(cs);String s = s.toLowerCase();String s = s.toUpperCase();String s = s.trim(); //去掉字符串两端多余的空格String s = String.valueOf(object);boolean equal=s1.equals(s2);//string左补0String a=String.format(\"%6d\",Integer.valueof(\"123\"))//输出000123//字典顺序比较两个Stringint res = a.compareTo(b);//a&lt;b,res&lt;0;a&gt;b,res&gt;0  ## StringBuilder &amp; StringBuffer 速度：StringBuilder &gt; StringBuffer &gt; String       线程不安全       线程安全         常量      StringBuilder sb = new StringBuilder(\"String\");sb.append(\"\");sb.reverse();sb.delete((int)start,(int)end); //[start,end)sb.deleteCharAt(int index);sb.insert((int)offset,\"String\");sb.toString();sb.setCharAt((int)index,(char)c);//翻转字符串StringBuffer sb = new StringBuffer(\"TestString\");sb.reverse();System.out.println(sb.toString()); ## 字符串组String[] a = new String[100];Arrays.sort(a);//与list转换  List&lt;Integer&gt; 和 int[] 因类型不同不可直接转换List&lt;String&gt; list = Arrays.asList(a);String[] b = (String[])list.toArray(new String[size]);//复制String[] c = Arrays.copyOfRange(String[] original,(int)start,(int)to)//[start,to)//填充Arrays.fill(a,\"fill\");JDK1.8集合框架Collection接口（一维集合）Collection接口是Set,List,Queue接口的父接口//Collectionadd(Object o);addAll(Collection c);clear();contains(Object o);remove(Object o);size();toArray();Collections.sort(Collection c);Collections.reverse(Collection c); 一维集合 set list queue//Set 不允许重复HashSet&lt;Object&gt; set = new HashSet&lt;&gt;();set.add(Object o);set.contains(Object o);set.remove(Object o);//List  有序集合，具有和索引有关的操作List&lt;Object&gt; list = new ArrayList&lt;&gt;();list.add((int)index,Object o);list.get((int)index);list.remove((int)index);list.indexOf(Object o);list.subList(int start,int end); [start,end);//list转arraylist1.stream().mapToInt(Integer::valueOf).toArray();//遍历1for(Integer t:res) {\tSystem.out.println(t);}//遍历2Iterator it=res.iterator();while(it.hasNext()){\tSystem.out.println(it.next());}                                  //Stack(LIFO)Stack&lt;Object&gt; s = new Stack&lt;&gt;();s.pop();//返回Objects.peek();//返回Objects.push(Object o);//返回Object                                  //Queue(FIFO)Queue&lt;Object&gt; q = new LinkedList&lt;&gt;();q.offer(Object o);q.peek();q.poll(); ## List转int数组//Arraylist转int[]//转为stream--intStream-调用toArray转为int[]List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();int[] res_a = a.stream().mapToInt(Integer::valueOf).toArray();//ArrayList转int[][]List&lt;int[]&gt; b = new ArrayList&lt;int[]&gt;();int[][] res_b = b.toArray(new int[0][]);//使用IntStream生成array //InStream接口中的静态方法：通过接口名调用。range 开区间 rangeclosed闭区间int[] res = IntStream.rangeClosed(0, 5).toArray();//[0,1,2,3,4,5]List组//长度为n的数组，每个元素是一个listList&lt;Integer&gt;[] a = new ArrayList[n];for(int i = 0; i &lt; n; i++) {    a[i] = new ArrayList&lt;Integer&gt;();}# Map接口（二维集合）HashTable，此类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值。HashMap,基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）LinkedHashMap，Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序，为插入顺序。TreeMap，基于红黑树，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。Map&lt;String,String&gt; map = new HashMap&lt;&gt;();map.put(\"key\",\"value\");map.getOrDefault(\"key\",\"default\");//if(map.containsKey(\"key\")) return \"value\" else return \"default\"map.get(\"key\"); //return \"value\";map.containsKey(\"key\");for(String s : map.keySet()){    map.get(s);//return value;}for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){    entry.getKey();    entry.getValue();}求余先忽略符号计算，最后判断符号（异号为－，同号为＋）位运算异或^if((n&amp;1)==1) ==的优先级高于&amp;，因此必须加括号位运算实现加法：异或保留 与进位，与为空时就返回移位运算符System.out.println(8 &lt;&lt; 2); //32//有符号右移，高位正数补0，负数补1//-1(11111111 11111111 11111111 11111111) 右移1位(01111111 11111111 11111111 11111111)//的结果是-1(11111111 11111111 11111111 11111111)System.out.println(-1 &gt;&gt; 1);// -1//无符号右移，高位补0//-1(11111111 11111111 11111111 11111111) 右移1位(01111111 11111111 11111111 11111111)//的结果是2147483647(Integer.MAX_VALUE)(01111111 11111111 11111111 11111111)System.out.println(-1 &gt;&gt;&gt; 1);大数（大于Double）运算import java.math.BigDecimal;public class test {    public static void main(String[] args) {    \tBigDecimal mybign=new BigDecimal(10);    \tBigDecimal res_pow=mybign.pow(10);    \tBigDecimal res_mul=mybign.multiply(new BigDecimal(10));    \tBigDecimal res_dev=mybign.divide(new BigDecimal(10));    \tBigDecimal res_rem=mybign.divideAndRemainder(new BigDecimal(10))[1];    \tSystem.out.println(res_pow.doubleValue()+\" \"+res_mul.intValue());    \tSystem.out.println(res_dev.intValue()+\" \"+res_rem.intValue());\t}} ## 进制转换import java.math.BigInteger;BigInteger a=new BigInteger(s,16);String b=a.toString(8);"
  },
  
  {
    "title": "Leetcode回溯",
    "url": "/posts/learn-backtrack/",
    "categories": "Leetcode",
    "tags": "leetcode",
    "date": "2023-04-13 14:10:00 +0800",
    





    
    "snippet": "引言跟着labuladong刷回溯题的记录。使用【回溯法】解决【子集、排列】问题：分为【子集 元素无重复】 【子集 元素有重复】 【排列 元素无重复】 【排列 元素有重复】四类。子集 无重leetcode 78给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。示例 1：输入：nums = [1,...",
    "content": "引言跟着labuladong刷回溯题的记录。使用【回溯法】解决【子集、排列】问题：分为【子集 元素无重复】 【子集 元素有重复】 【排列 元素无重复】 【排列 元素有重复】四类。子集 无重leetcode 78给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。示例 1：输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]示例 2：输入：nums = [0]输出：[[],[0]]在回溯时传递i：class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        backtrac(nums, 0);        return res;    }    public void backtrac(int[] nums, int i){    \t//每个节点的值都是一个结果        res.add(new LinkedList&lt;Integer&gt;(path));        int n = nums.length;        for(int j = i; j &lt; n; j++){            path.addLast(nums[j]);            backtrac(nums, j + 1);            path.removeLast();        }    }} # 子集 有重 [leetcode90](https://leetcode.cn/problems/subsets-ii/)给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。示例 1：输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]示例 2：输入：nums = [0]输出：[[],[0]]先对元素排序，使相同的元素相邻，搜索时若当前元素和前一元素相同，剪枝当前元素class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        Arrays.sort(nums);        backtrack(nums, 0);        return res;    }    public void backtrack(int[] nums, int i){        res.add(new LinkedList(path));        for(int j = i; j &lt; nums.length; j++){            if(j &gt; i &amp;&amp; nums[j] == nums[j - 1]){//不是j&gt;0，j&gt;0就剪多了，j&gt;0会导致j=i时也被剪                continue;            }            path.add(nums[j]);            backtrack(nums,  j + 1);            path.removeLast();        }    }} # 排列 无重 [leetcode 46](https://leetcode.cn/problems/permutations/)给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。示例 1：输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2：输入：nums = [0,1]输出：[[0,1],[1,0]]排除使用过的元素，没有重复元素，只需要排除当前path中已经包含的元素class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        backtrack(nums);        return res;    }    public void backtrack(int[] nums){        if(path.size() == nums.length){            res.add(new LinkedList&lt;&gt;(path));            return;        }        for(int i = 0; i &lt; nums.length; i++){            //排序已经包含的元素            if(path.contains(nums[i])){                continue;             }            //做选择            path.add(nums[i]);            backtrack(nums);            //撤销选择            path.removeLast();        }    }} # 排列 有重 [leetcode 47](https://leetcode.cn/problems/permutations-ii/)​给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。示例 1：输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]示例 2：输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\t\t **先对元素排序，使相同元素相邻。** 因为存在相同元素，直接全排列会搜索到[1, 1', 2]和[1', 1, 2]的相同结果，去重的方式为：**保证相同元素在排列结果中的相对顺序**。也就是：当我们搜到第1'时，必须保证1已经使用过，因此若前一相同元素未被使用，剪枝。class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    boolean[] used;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {         Arrays.sort(nums);         int n = nums.length;         used = new boolean[n];         backtrack(nums);         return res;    }    public void backtrack(int[] nums){        int n = nums.length;        if(path.size() == n){            res.add(new LinkedList&lt;&gt;(path));            return;        }        for(int j = 0; j &lt; n; j++){            if(used[j]){                continue;            }            if(j &gt; 0 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; !used[j - 1]){                continue;            }            path.add(nums[j]);            used[j] = true;            backtrack(nums);            path.removeLast();            used[j] = false;        }    }}总结子集只能选择当前位置后面的元素，通过在回溯时传递搜索的起始索引实现。若元素有重，先排序，搜索到重复元素（当前元素和前一元素相同）时，剪枝。排列不能选择用过的数字，通过判断path中是否存在或者使用used数组记录。若元素有重，先排序，需要保证相同元素在结果中的相对顺序是一致的，因此：搜索到重复元素（当前元素和前一元素相同）且 前一元素未被使用 时，剪枝。"
  }
  
]

