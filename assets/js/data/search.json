[
  
  {
    "title": "DP-背包问题",
    "url": "/posts/leetcode-dp-bag/",
    "categories": "LeetCode",
    "tags": "LeetCode",
    "date": "2023-04-18 15:00:00 +0800",
    





    
    "snippet": "背包问题属于动态规划的一类问题，需要明确状态和选择。状态：背包的容量 和 可选择的物品；选择：装 和 不装01背包：每个物品只能装一次，选择装/不装。定义状态转移方程dp[i][w]：对于前i个物品，当前背包的容量是w时，可以获得的最大价值是dp[i][w]。int[][] dp = new int[N+1][M+1]//base casedp[0][...] = 0dp[...][0] =...",
    "content": "背包问题属于动态规划的一类问题，需要明确状态和选择。状态：背包的容量 和 可选择的物品；选择：装 和 不装01背包：每个物品只能装一次，选择装/不装。定义状态转移方程dp[i][w]：对于前i个物品，当前背包的容量是w时，可以获得的最大价值是dp[i][w]。int[][] dp = new int[N+1][M+1]//base casedp[0][...] = 0dp[...][0] = 0//使用wt[i-1]表示第i个物品的重量 val[i-1]表示第i个物品的价值for i in [1...N]:    for w in [1...M]:        //考虑                 不装入     装入        dp[i][w] = Math.max(dp[i-1][w],  dp[i-1][w-wt[i-1]] + val[i-1])return dp[N][M]子集背包：每个物品只能装一次，将寻找子集问题转换为背包问题。leetcode 416给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。示例 1：输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。示例 2：输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。本题等价于：每个物品重量为nums[i]，对于前n个物品，是否能找到一种装法，恰好将容量为sum/2的背包装满，从而可以套用背包问题的模板解答。定义dp数组：boolean[] dp[i][w]，含义为对于前i个物品，当前背包容量为w时，是否存在一种方法可以恰好将背包装满。则答案为dp[n][sum/2]。class Solution {    public boolean canPartition(int[] nums) {        int n = nums.length;        int sum = 0;        for(int i = 0; i &lt; n; i++){            sum += nums[i];        }        if(sum % 2 == 1) return false;        //前i个物品，容量为j的背包        boolean[][] dp = new boolean[n + 1][sum / 2 + 1];        for(int i = 0; i &lt; n + 1; i++){            dp[i][0] = true;;        }        for(int i = 1; i &lt; n + 1; i++){            for(int j = 1; j &lt; sum / 2 + 1; j++){                if(j - nums[i - 1] &gt;= 0){                    //考虑不装入和装入，注意在装入当前物品时，考虑的是i-1个商品是否能恰好装满                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];                 }else{                    dp[i][j] = dp[i - 1][j];                }            }        }        return dp[n][sum / 2];    }}完全背包：物品数量无限。对状态转移方程做修改leetcode 518给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。示例 1：输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1示例 2：输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。示例 3：输入：amount = 10, coins = [10] 输出：1定义dp[i][w]数组，对于前i个物品，凑出价值的w的方法有多少种。class Solution {    public int change(int amount, int[] coins) {        int n = coins.length;        //对于前i个商品，背包容量为amount时，可以凑出的方法有几种        int[][] dp = new int[n + 1][amount + 1];        for(int i = 0; i &lt; n + 1; i++){            dp[i][0] = 1;//容量为0，不需要装硬币，便可以凑出结果。        }        for(int i = 1; i &lt; n + 1; i++){            for(int j = 1; j &lt; amount + 1; j++){                if(j - coins[i - 1] &gt;= 0){                    //因为物品可以重复使用，注意在选择装入的请款下这里考虑的仍然是前i个物品                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i -1]];                }else{                    dp[i][j] = dp[i - 1][j];                }            }        }        return dp[n][amount];    }}"
  },
  
  {
    "title": "DP",
    "url": "/posts/leetcode-dp/",
    "categories": "LeetCode",
    "tags": "LeetCode",
    "date": "2023-04-14 20:40:00 +0800",
    





    
    "snippet": "引言跟着labuladong刷动态规划题的记录。DP三要素：重叠子问题、最优子结构、状态转移方程重叠子问题计算Fibonacci数列时，f(4) = f(3) + f(2), f(3) = f(2) + f(1), f(2)会重复计算两次，为一个重叠的子问题。若暴力递归，进行重复计算，时间复杂度为$O(2 ^ n)$;为了避免重复计算，引入备忘录，存储子问题的答案，时间复杂度降低为$O(n)...",
    "content": "引言跟着labuladong刷动态规划题的记录。DP三要素：重叠子问题、最优子结构、状态转移方程重叠子问题计算Fibonacci数列时，f(4) = f(3) + f(2), f(3) = f(2) + f(1), f(2)会重复计算两次，为一个重叠的子问题。若暴力递归，进行重复计算，时间复杂度为$O(2 ^ n)$;为了避免重复计算，引入备忘录，存储子问题的答案，时间复杂度降低为$O(n)$。状态转移方程受备忘录启发，引入DP table，存储子问题的答案，完成自底向上的推算，即列出状态转移方程。如Fibonacci：dp[n] = dp[n - 1] + dp[n - 2], n &gt; 1。更进一步，由于n的状态只跟n-1和n-2相关，只需要存储前两个状态，可以使用2个变量滚动更新。写状态转移方程的思路：base case -&gt; 状态 -&gt; 选择 -&gt; 定义dp数组最优子结构例如，想考出最高的成绩，则子问题为每门课程的成绩最高，因为每门课程的成绩互相独立，满足最优子结构。零钱兑换leetcode 322给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。示例 1：输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1示例 2：输入：coins = [2], amount = 3输出：-1示例 3：输入：coins = [1], amount = 0输出：0dp[11] = Math.min(dp[10], dp[9], dp[6]) + 1递归-自上而下class Solution {    public int coinChange(int[] coins, int amount) {        int[] mem = new int[amount + 1];        Arrays.fill(mem, - 100);        mem[0] = 0;        return dp(coins, amount, mem);    }        //凑amount零钱需要的最小coin数量    public int dp(int[] coins, int amount, int[] mem){        //base case        if(amount == 0) return 0;        if(amount &lt; 0) return -1;        if(mem[amount] != - 100) return mem[amount];        //caculate the best ans        int res = Integer.MAX_VALUE;        for(int coin: coins){            int sub = dp(coins, amount - coin, mem);            if(sub == -1) continue;            res = Math.min(res, sub + 1);         }        res = res == Integer.MAX_VALUE ? -1 : res;        mem[amount] = res;        return res;         }}迭代-自底向上class Solution {    public int coinChange(int[] coins, int amount) {        //凑成amount需要的最少硬币数量        //初始化一个最大值        int[] dp = new int[amount + 1];        Arrays.fill(dp, amount + 1);        dp[0] = 0;        for(int i = 1; i &lt; amount + 1; i++){            for(int coin: coins){                if(i - coin &lt; 0)continue;                dp[i] = Math.min(dp[i], dp[i - coin] + 1);            }        }        return dp[amount] == amount + 1 ? -1 : dp[amount];    }}最长公共子序列leetcode 1143给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。示例 1：输入：text1 = \"abcde\", text2 = \"ace\" 输出：3  解释：最长公共子序列是 \"ace\" ，它的长度为 3 。示例 2：输入：text1 = \"abc\", text2 = \"abc\"输出：3解释：最长公共子序列是 \"abc\" ，它的长度为 3 。示例 3：输入：text1 = \"abc\", text2 = \"def\"输出：0解释：两个字符串没有公共子序列，返回 0 。关键在于寻找状态转移方程class Solution {    public int longestCommonSubsequence(String text1, String text2) {        int m = text1.length();        int n = text2.length();        if(m == 0 || n == 0) return 0;        int[][] dp = new int[m + 1][n + 1];                for(int i = 1; i &lt; m + 1; i++){            for(int j = 1; j &lt; n + 1; j++){                if(text1.charAt(i - 1) == text2.charAt(j - 1)){                    dp[i][j] = dp[i-1][j-1] + 1;                }else{                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);                }            }        }        return dp[m][n];    }}"
  },
  
  {
    "title": "回溯",
    "url": "/posts/leetcode-backtrack/",
    "categories": "LeetCode",
    "tags": "LeetCode",
    "date": "2023-04-13 14:10:00 +0800",
    





    
    "snippet": "引言跟着labuladong刷回溯题的记录。使用【回溯法】解决【子集、排列】问题：分为【子集 元素无重复】 【子集 元素有重复】 【排列 元素无重复】 【排列 元素有重复】四类。子集 无重leetcode 78给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。示例 1：输入：nums = [1,...",
    "content": "引言跟着labuladong刷回溯题的记录。使用【回溯法】解决【子集、排列】问题：分为【子集 元素无重复】 【子集 元素有重复】 【排列 元素无重复】 【排列 元素有重复】四类。子集 无重leetcode 78给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。示例 1：输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]示例 2：输入：nums = [0]输出：[[],[0]]在回溯时传递i：class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        backtrac(nums, 0);        return res;    }    public void backtrac(int[] nums, int i){    \t//每个节点的值都是一个结果        res.add(new LinkedList&lt;Integer&gt;(path));        int n = nums.length;        for(int j = i; j &lt; n; j++){            path.addLast(nums[j]);            backtrac(nums, j + 1);            path.removeLast();        }    }} # 子集 有重 [leetcode90](https://leetcode.cn/problems/subsets-ii/)给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。示例 1：输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]示例 2：输入：nums = [0]输出：[[],[0]]先对元素排序，使相同的元素相邻，搜索时若当前元素和前一元素相同，剪枝当前元素class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        Arrays.sort(nums);        backtrack(nums, 0);        return res;    }    public void backtrack(int[] nums, int i){        res.add(new LinkedList(path));        for(int j = i; j &lt; nums.length; j++){            if(j &gt; i &amp;&amp; nums[j] == nums[j - 1]){//不是j&gt;0，j&gt;0就剪多了，j&gt;0会导致j=i时也被剪                continue;            }            path.add(nums[j]);            backtrack(nums,  j + 1);            path.removeLast();        }    }} # 排列 无重 [leetcode 46](https://leetcode.cn/problems/permutations/)给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。示例 1：输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2：输入：nums = [0,1]输出：[[0,1],[1,0]]排除使用过的元素，没有重复元素，只需要排除当前path中已经包含的元素class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        backtrack(nums);        return res;    }    public void backtrack(int[] nums){        if(path.size() == nums.length){            res.add(new LinkedList&lt;&gt;(path));            return;        }        for(int i = 0; i &lt; nums.length; i++){            //排序已经包含的元素            if(path.contains(nums[i])){                continue;             }            //做选择            path.add(nums[i]);            backtrack(nums);            //撤销选择            path.removeLast();        }    }} # 排列 有重 [leetcode 47](https://leetcode.cn/problems/permutations-ii/)​给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。示例 1：输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]示例 2：输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\t\t **先对元素排序，使相同元素相邻。** 因为存在相同元素，直接全排列会搜索到[1, 1', 2]和[1', 1, 2]的相同结果，去重的方式为：**保证相同元素在排列结果中的相对顺序**。也就是：当我们搜到第1'时，必须保证1已经使用过，因此若前一相同元素未被使用，剪枝。class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    boolean[] used;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {         Arrays.sort(nums);         int n = nums.length;         used = new boolean[n];         backtrack(nums);         return res;    }    public void backtrack(int[] nums){        int n = nums.length;        if(path.size() == n){            res.add(new LinkedList&lt;&gt;(path));            return;        }        for(int j = 0; j &lt; n; j++){            if(used[j]){                continue;            }            if(j &gt; 0 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; !used[j - 1]){                continue;            }            path.add(nums[j]);            used[j] = true;            backtrack(nums);            path.removeLast();            used[j] = false;        }    }}总结子集只能选择当前位置后面的元素，通过在回溯时传递搜索的起始索引实现。若元素有重，先排序，搜索到重复元素（当前元素和前一元素相同）时，剪枝。排列不能选择用过的数字，通过判断path中是否存在或者使用used数组记录。若元素有重，先排序，需要保证相同元素在结果中的相对顺序是一致的，因此：搜索到重复元素（当前元素和前一元素相同）且 前一元素未被使用 时，剪枝。"
  },
  
  {
    "title": "Java常用代码",
    "url": "/posts/learn-java/",
    "categories": "Java基础",
    "tags": "Java",
    "date": "2023-04-13 14:10:00 +0800",
    





    
    "snippet": "在线文档https://www.matools.com/api/java8从键盘输入Scanner sc =new Scanner(System.in);Integer a=sc.nextInt();int、Integer、Doubleint为基本数据类型，Integer为int对应的包装类。在范型中使用IntegerHashMap&lt;String,Integer&gt; mymap=n...",
    "content": "在线文档https://www.matools.com/api/java8从键盘输入Scanner sc =new Scanner(System.in);Integer a=sc.nextInt();int、Integer、Doubleint为基本数据类型，Integer为int对应的包装类。在范型中使用IntegerHashMap&lt;String,Integer&gt; mymap=new HashMap&lt;String,Integer&gt;(); 判断两个int是否相等或Integer与int是否相等，用== 判断两个Integer是否相等用.equals()System.out.println(m.peekFirst()==q.peek()); //not always trueSystem.out.println(m.peekFirst().equals(q.peek()));//Trueint ans=q.peek();System.out.println(m.peekFirst()==ans);//True//int转doubleDouble v=Double.valueOf(intvalue);//double转IntInteger a=(int)doublevalue; //强制转换默认舍弃小数点后的数 Integer b=(int)Math.round(doublevalule);//Math.round四舍五入                //按格式输出String.format(\"%5d\",Integer.valueof(\"3\"));String.format(\"%.2f\",Double.valueof(\"3\"));//四舍五入并保留小数BigDecimal bd=new BigDecimal(\"133.227878\");bd=bd.setScale(5,RoundingMode.HALF_UP);//RoundingMode.UP Roundingode.DOWN最大值最小值//Float Double Byte Character Short Integer LongImax = Integer.MAX_VALUE;Imin = Integer.MIN_VALUE;Math.max((int)a,(int)b);Math.min((int)a,(int)b);排序Arrays.sort()对数组排序，重载了四类方法● sort(T[] a)：对指定T型数组按数字升序排序。● sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。● sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。● sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。Comparator的compare方法默认从小到大（o1的优先级高于o2）：若参数o1&lt;参数o2,返回负值，o1=o2返回0，o1&gt;o2返回正值。//Arrays.sort只支持对包装类进行自定义排序Integer[] a=new Integer[n];//比较器写法//降序排序需要自定义comparatorComparator cmp = new MyComparator();Arrays.sort(a, cmp);class MyComparator implements Comparator&lt;Integer&gt; {    //如果o1小于o2，我们就返回正值，如果o1大于o2我们就返回负值，    //这样颠倒一下，就可以实现反向排序了    @Override    public int compare(Integer o1, Integer o2) {        return o2-o1;    }}//lamda写法Arrays.sort(a, (n1,n2)-&gt;{    return n2 - n1;}); Collections.sort()对List&lt;T&gt;排序 ● sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c):根据指定比较器产生的顺序对指定List进行排序。字符串String转int/longint a = Integer.parseInt(string);long la = Long.parseLong(string); # Int转StringString s = String.valueOf(a);String s = a + \"\";//int转不同进制的Stringint i = 2023;String s = Integer.toBinaryString(i);String s = Integer.toOctalString(i);String s = Integer.toString(i);String s = Integer.toHexString(i); ## StringString s = \"asdefgasdefg\";for(int i = 0; i &lt; s.length(); i++){    char c = s.charAt(i);}s.indexOf('s') //retrun 1s.indexof('s',2) //return 7s.lastIndexOf('s') //return 7s.lastIndexOf('s',6)//return 1string[] ss = s.split(String a);//以字符串a分割字符串String s = s.substring((int)start,(int)end)//[start,end)//String与char数组的转换char[] cs = s.toCharArray();String s = new String(cs);String s = s.toLowerCase();String s = s.toUpperCase();String s = s.trim(); //去掉字符串两端多余的空格String s = String.valueOf(object);boolean equal=s1.equals(s2);//string左补0String a=String.format(\"%6d\",Integer.valueof(\"123\"))//输出000123//字典顺序比较两个Stringint res = a.compareTo(b);//a&lt;b,res&lt;0;a&gt;b,res&gt;0 StringBuilder &amp; StringBuffer速度：StringBuilder &gt; StringBuffer &gt; String    线程不安全     线程安全   常量StringBuilder sb = new StringBuilder(\"String\");sb.append(\"\");sb.reverse();sb.delete((int)start,(int)end); //[start,end)sb.deleteCharAt(int index);sb.insert((int)offset,\"String\");sb.toString();sb.setCharAt((int)index,(char)c);//翻转字符串StringBuffer sb = new StringBuffer(\"TestString\");sb.reverse();System.out.println(sb.toString()); ## 字符串组String[] a = new String[100];Arrays.sort(a);//与list转换  List&lt;Integer&gt; 和 int[] 因类型不同不可直接转换List&lt;String&gt; list = Arrays.asList(a);String[] b = (String[])list.toArray(new String[size]);//复制String[] c = Arrays.copyOfRange(String[] original,(int)start,(int)to)//[start,to)//填充Arrays.fill(a,\"fill\");JDK1.8集合框架Collection接口（一维集合）Collection接口是Set,List,Queue接口的父接口//Collectionadd(Object o);addAll(Collection c);clear();contains(Object o);remove(Object o);size();toArray();Collections.sort(Collection c);Collections.reverse(Collection c); 一维集合 set list queue//Set 不允许重复HashSet&lt;Object&gt; set = new HashSet&lt;&gt;();set.add(Object o);set.contains(Object o);set.remove(Object o);//List  有序集合，具有和索引有关的操作List&lt;Object&gt; list = new ArrayList&lt;&gt;();list.add((int)index,Object o);list.get((int)index);list.remove((int)index);list.indexOf(Object o);list.subList(int start,int end); [start,end);//list转arraylist1.stream().mapToInt(Integer::valueOf).toArray();//遍历1for(Integer t:res) {\tSystem.out.println(t);}//遍历2Iterator it=res.iterator();while(it.hasNext()){\tSystem.out.println(it.next());}                                  //Stack(LIFO)Stack&lt;Object&gt; s = new Stack&lt;&gt;();s.pop();//返回Objects.peek();//返回Objects.push(Object o);//返回Object                                  //Queue(FIFO)Queue&lt;Object&gt; q = new LinkedList&lt;&gt;();q.offer(Object o);q.peek();q.poll(); ## List转int数组//Arraylist转int[]//转为stream--intStream-调用toArray转为int[]List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();int[] res_a = a.stream().mapToInt(Integer::valueOf).toArray();//ArrayList转int[][]List&lt;int[]&gt; b = new ArrayList&lt;int[]&gt;();int[][] res_b = b.toArray(new int[0][]);//使用IntStream生成array //InStream接口中的静态方法：通过接口名调用。range 开区间 rangeclosed闭区间int[] res = IntStream.rangeClosed(0, 5).toArray();//[0,1,2,3,4,5]List组//长度为n的数组，每个元素是一个listList&lt;Integer&gt;[] a = new ArrayList[n];for(int i = 0; i &lt; n; i++) {    a[i] = new ArrayList&lt;Integer&gt;();}# Map接口（二维集合）HashTable，此类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值。HashMap,基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）LinkedHashMap，Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序，为插入顺序。TreeMap，基于红黑树，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。Map&lt;String,String&gt; map = new HashMap&lt;&gt;();map.put(\"key\",\"value\");map.getOrDefault(\"key\",\"default\");//if(map.containsKey(\"key\")) return \"value\" else return \"default\"map.get(\"key\"); //return \"value\";map.containsKey(\"key\");for(String s : map.keySet()){    map.get(s);//return value;}for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){    entry.getKey();    entry.getValue();}求余先忽略符号计算，最后判断符号（异号为－，同号为＋）位运算异或^if((n&amp;1)==1) ==的优先级高于&amp;，因此必须加括号位运算实现加法：异或保留 与进位，与为空时就返回移位运算符System.out.println(8 &lt;&lt; 2); //32//有符号右移，高位正数补0，负数补1//-1(11111111 11111111 11111111 11111111) 右移1位(01111111 11111111 11111111 11111111)//的结果是-1(11111111 11111111 11111111 11111111)System.out.println(-1 &gt;&gt; 1);// -1//无符号右移，高位补0//-1(11111111 11111111 11111111 11111111) 右移1位(01111111 11111111 11111111 11111111)//的结果是2147483647(Integer.MAX_VALUE)(01111111 11111111 11111111 11111111)System.out.println(-1 &gt;&gt;&gt; 1);大数（大于Double）运算import java.math.BigDecimal;public class test {    public static void main(String[] args) {    \tBigDecimal mybign=new BigDecimal(10);    \tBigDecimal res_pow=mybign.pow(10);    \tBigDecimal res_mul=mybign.multiply(new BigDecimal(10));    \tBigDecimal res_dev=mybign.divide(new BigDecimal(10));    \tBigDecimal res_rem=mybign.divideAndRemainder(new BigDecimal(10))[1];    \tSystem.out.println(res_pow.doubleValue()+\" \"+res_mul.intValue());    \tSystem.out.println(res_dev.intValue()+\" \"+res_rem.intValue());\t}} ## 进制转换import java.math.BigInteger;BigInteger a=new BigInteger(s,16);String b=a.toString(8);"
  },
  
  {
    "title": "wsl创建ubuntu+mysql安装+redis安装",
    "url": "/posts/wsl/",
    "categories": "Java基础",
    "tags": "Java",
    "date": "2023-03-15 14:10:00 +0800",
    





    
    "snippet": "方式一 vmware安装安装vmware,下载ubuntu的iso文件ubuntu-releases安装包下载_开源镜像站-阿里云i386是32位 amd64是64位方式二 wsl安装1. 在启动或关闭Windows功能中，打开以下两项，重启 2. powershell以管理员身份打开在mic store安装分发版也可查看已经安装的分发版打开Ubuntu报错：WslRegisterDistr...",
    "content": "方式一 vmware安装安装vmware,下载ubuntu的iso文件ubuntu-releases安装包下载_开源镜像站-阿里云i386是32位 amd64是64位方式二 wsl安装1. 在启动或关闭Windows功能中，打开以下两项，重启 2. powershell以管理员身份打开在mic store安装分发版也可查看已经安装的分发版打开Ubuntu报错：WslRegisterDistribution failed with error: 0x800701bc原因是：wsl1升级到wsl2之后，内核没有升级。解决方法：  下载最新的wsl安装包，  安装包下载后，直接运行安装。 下载地址：https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi搜索Ubuntu或者Debian即可打开~WSL下的mysql安装sudo apt-get install mysql-server安装后默认创建root用户，没有密码，登录：mysql -u root报错：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)查看sql状态service mysql status重启sqlservice mysql restart不知道为什么这里重启一下就好了。。。。登录mysql -u rootWSL下的redis安装安装redissudo apt-get updatesudo apt-get install redis-server查看redis版本redis-server -v查看redis状态在linux系统上使用：sudo systemctl status redis-server wsl没有systemctl模块，报错：System has not been booted with systemd as init system (PID 1). Can’t operate.Failed to connect to bus: Host is down使用：sudo service redis-server status启动redis服务sudo service redis-server start进入redis环境redis-cli查看端口占用sudo lsof -i:xxxx查看本机ipsudo apt install net-tools //没有的话安装ifconfiginet:本机ip  netmask:网络掩码  broadcast:广播地址  ether:物理地址查看redis进程ps -aux|grep redis查看redis连接信息redis-cliinfo //查看信息info Clients //查看用户信息wsl以自定义的用户和密码登录，若需启用root权限，先设置root密码sudo passwd root切换root权限su配置redis远程访问查看redis目录在哪whereis redis进入redis目录 修改redis.confvim redis.conf找到bind 127.0.0.1 ::1，把他注释掉bind指的是只有指定的网段才能远程访问redis，因此注释掉同时找到preotected-mode这一行，将yes改为no保存文件，重启redisservice redis-server restart配置防火墙，允许网络流量通过TCP端口6379sudo ufw allow proto tcp from xxx.xxx.x.xxx to any port 6379使用redis-cli从远程机器上ping redis服务器redis-cli -h xxx.xx.xxx.xxx ping收到一个PONG即设置完成~"
  },
  
  {
    "title": "跑Swin-Transformer-Object-Detection过程中遇到的坑及解决",
    "url": "/posts/swin/",
    "categories": "深度学习",
    "tags": "Python",
    "date": "2021-12-26 14:10:00 +0800",
    





    
    "snippet": "代码地址：GitHub - SwinTransformer/Swin-Transformer-Object-Detection: This is an official implementation for “Swin Transformer: Hierarchical Vision Transformer using Shifted Windows” on Object Detection...",
    "content": "代码地址：GitHub - SwinTransformer/Swin-Transformer-Object-Detection: This is an official implementation for “Swin Transformer: Hierarchical Vision Transformer using Shifted Windows” on Object Detection and Instance Segmentation.BUG1:安装mmcv报了undefined symbol的错，大概如下undefined symbol: _ZN3c105ErrorC1ENS_14SourceLocationENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE根据mmcv文档Frequently Asked Questions — MMDetection 2.19.1 documentation但查看了pytorch版本和gcc版本都是没有问题的。但基本可以确定是版本问题。Solve:根据所用的cuda和pytorch版本到https://download.openmmlab.com/mmcv/dist/cu110/torch1.7.0/index.html查看和python版本也相匹配的mmcv版本，用pip安装pip install https://download.openmmlab.com/mmcv/dist/cu110/torch1.7.0/mmcv_full-1.3.9-cp36-cp36m-manylinux1_x86_64.whl解决！BUG2:AssertionError: The `num_classes` (80) in FCNMaskHead of MMDataParallel does not matches the length of `CLASSES` 8) in..FCNMaskHead检测头的类别设置不对Solve:在configs/swin/下用到的配置文件config.py中修改类别为8.BUG3:AssertionError: Default process group is not initialized非分布式的代码用了分布式的设置解决：参考github的issuesCheck your config file and replace all “SyncBN” entries to “BN”, that should help.BUG4:使用cityscapes数据集训练时，在mmdet下的文件这一行seg_map=img_info[‘segm_file’])报了keyrrror的错，就是说img_info中没有segm_file这个keySolve:数据集的问题，使用/tools/dataset_converters/cityscapes.py代码将cityscapes转换为coco格式。BUG5:mmdet/core/mask/mask_target.py的文件里报了typeerror的错，TypeError: 'NoneType' object is not iterable in Python似乎是传入的mask是NoneTypeSolve:模型用的是cascade mask rcnn，但configs/_base_/datasets/用的是cityscapes_detection的配置文件，detection设置mask为false，就是没有给模型传入mask，修改为cityscapes_instance的配置文件，解决！大概就记得这么多，就是说，没有GITHUB和GOOGLE解决不了的BUG！"
  }
  
]

